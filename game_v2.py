"""
УСЛОЖНЯЕМ ЗАДАЧУ
Теперь напишем более сложную версию игры: пусть компьютер сам загадывает и отгадывает числа

Обратите внимание, что в аргументах функции мы через двоеточие указываем тип данных для ввода (int), через равно — стандартное 
значение этого типа данных. Стрелка (->) указывает, какой тип данных мы должны получить на выходе. Это упростит заполнение 
документации (VS Code сможет автоматически генерировать её), а также позволит в дальнейшем эффективнее работать с ошибками.

Сгенерируем документацию для нашей функции. Для этого в теле функции прописываем тройные кавычки (символ docstring), и, 
если у вас установлено расширение Python Docstring Generator, шаблон документации будет создан автоматически. 
На месте [summary] прописываем описание функции, а вместо [description] указываем описание аргументов и возвращаемого значения:
"""

import numpy as np

def random_predict(number:int=1) -> int:
    """Рандомно угадываем число
    Args:
        number (int, optional): Загаданное число. Defaults to 1.

    Returns:
        int: Число попыток
    """
    count = 0

    while True:
        count += 1
        predict_number = np.random.randint(1, 101) # предполагаемое число
        if number == predict_number:
            break # выход из цикла, если угадали
    return(count)

# print(f'Количество попыток: {random_predict()}')

if __name__ == '__main__':
    random_predict()


"""
ВНОВЬ МОДИФИЦИРУЕМ ЗАДАЧУ

Напишем функцию score_game(), определяющую среднее количество попыток угадывания числа. 
Аргументом функции будет другая функция, с помощью которой и реализуется угадывание числа. 
Пропишем для этой функции документацию. Алгоритм работы функции вы можете прочитать в комментариях:
"""
def score_game(random_predict) -> int:
    """За какое количество попыток в среднем из 1000 подходов угадывает наш алгоритм

    Args:
        random_predict (_type_): функция угадывания

    Returns:
        int: среднее количество попыток
    """
    
    count_ls = [] # список для сохранения количества попыток
    np.random.seed(1) # фиксируем сид для воспроизводимости
    random_array = np.random.randint(1, 101, size=(1000)) # загадали список чисел

    for number in random_array:
        count_ls.append(random_predict(number))

    score = int(np.mean(count_ls)) # находим среднее количество попыток

    print(f'Ваш алгоритм угадывает число в среднем за: {score} попыток')
    return(score)


# score_game(random_predict)  # что бы в jupyter notebook файл запускался только после нашего вызова

"""
ПОДВЕДЁМ ИТОГ ПО СОЗДАННОМУ КОДУ

На самом деле мы с вами создали маленькую библиотеку game_v2.py. Она содержит в себе две документированные функции: 
random_predict() и score_game(). Мы можем импортировать их из других файлов и использовать в дальнейшем. Этим мы с вами 
займёмся в следующем юните.
"""

#                                 РАБОТА В JUPYTER NOTEBOOK

"""
Если импортировать данный файл в jupyter notebook (import game_v2), то при запуске тут же увидим результат вывода
Это происходит из-за того, что в нашем файле game_v2.py прописан вызов функции score_game(). Это не совсем корректно — 
библиотека не должна запускать свои функции, пока мы сами их не вызовем в главном файле.

Это можно исправить. Чтобы отделить вызовы функций от импорта, необходимо в файле game_v2.py 
перенести вызовы функций в следующую конструкцию:
"""

if __name__ == '__main__':
    score_game(random_predict)

"""
Условие __name__ == '__main__' выполнится только тогда, когда файл game_v2.py будет исполняемым (когда мы запускаем 
файл через RUN). Если файл является импортируемым (используется в качестве внешнего модуля), то условие не будет 
выполняться и функция score_game() не будет вызываться.

Теперь мы будем выполнять импортируемый код следующим образом:
Это уже в jupyter notebook:

game_v2.score_game(game_v2.random_predict)

Примечание. Для того чтобы обратиться к функции из модуля game_v2, мы должны сначала обратиться к модулю game_v2, 
который мы импортировали выше, а затем через точку обратиться к функции, которая находится в этом модуле.

На самом деле, выполнять код таким образом не совсем корректно — лучше указать, из какой библиотеки 
(в данном случае — соседний файл, game_v2.py) мы производим импорт. Корректный импорт будет выглядеть так:
from game_v2 import score_game
from game_v2 import random_predict
score_game(random_predict) #вызов функции

можно перечислить нужные нам из этого модуля функции через запятую:
from game_v2 import score_game, random_predict
"""  

"""
Важно! Хорошим тоном считается переносить код в файлы Python, чтобы с ним было проще работать на 
продакшене, а в Jupyter Notebook делать исключительно презентацию.

Тем не менее, иногда требуется скопировать в ноутбук и сам код (например, когда нам необходимо переслать только ноутбук, 
без файлов Python). После вставки в ячейку код будет выполняться точно так же, как и в случае с импортом, но уже напрямую.

Также благодаря интерактивности в ноутбуке намного удобнее работать с отображением таблиц и визуализацией данных. 
Поэтому Jupyter Notebook чаще всего используется для исследования и предобработки данных, а построение и 
обучение ML-моделей, как правило, выносят в файлы .py. Но всё это — дело вкуса.
"""

"""
Ещё одна особенность Jupyter Notebook в VS Code — возможность просмотра переменных. При изменении переменных 
мы также сможем увидеть результат этих изменений.

Например, объявим в одной из ячеек несколько переменных:
n = 10
z = n
n = 5
С помощью меню Variables мы можем просмотреть значения всех глобальных переменных, которые объявлены в ноутбуке
Эта особенность бывает очень полезна, когда ноутбук содержит большое количество кода и вам нужно отслеживать 
значения переменных.  
"""

"""
Теперь давайте оформим наш ноутбук, чтобы он выглядел эстетично. Это можно реализовать с помощью языка Markdown. 
Он помогает привести ноутбук к формату презентаций. Вы будете использовать Markdown в своих домашних заданиях 
на протяжении всего курса, чтобы прописывать в ячейках свои выводы по полученным результатам.

Создадим заголовки с помощью Markdown

С помощью символа # можно создавать заголовки разных уровней (# — первый уровень, ## — второй уровень и т. д.).

# Игра угадай число
## Угадываем рандомно   
"""